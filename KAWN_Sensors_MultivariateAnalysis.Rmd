---
title: 'KAWN: Parameters vs Energetics'
author: "Michelle Catherine Kelly"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(lubridate)
library(tidyr)
library(grid)
library(gridExtra)
library(dplyr)
library(ggplot2)
library(ggpmisc)
```


```{r dataload}
# pulling from the streamPULSE API will just pull in data that's useful for metabolism modeling, but we're interested in all data available. Therefore, download data from streamPULSE and load in these .csv files. 

# load sensor data from local files (same files as can be downloaded from streamPULSE)
eric_data <- read.csv("./SensorData_StreamPULSE_Downloaded/KS_KANSASREASTLAWRENCE_sensorData.csv",
                      header = TRUE)
steve_data <- read.csv("./SensorData_StreamPULSE_Downloaded/KS_KANSASRFALLLEAF_sensorData.csv", 
                      header = TRUE)
desoto_data <- read.csv("./SensorData_StreamPULSE_Downloaded/KS_KANSASR_sensorData.csv", 
                        header = TRUE)

# make sure datetime is of correct class
eric_data$DateTime_UTC <- lubridate::mdy_hm(eric_data$DateTime_UTC)
steve_data$DateTime_UTC <- lubridate::mdy_hm(steve_data$DateTime_UTC)
desoto_data$DateTime_UTC <- lubridate::mdy_hm(desoto_data$DateTime_UTC)

# load in metabolism model results
modelfit.eric <- readRDS("./StreamMetabolismModels/MetabResults_Eric.RData")$predictions
modelfit.steve <- readRDS("./StreamMetabolismModels/MetabResults_Steve.RData")$predictions
modelfit.desoto <- readRDS("./StreamMetabolismModels/MetabResults_Desoto.RData")$predictions

# create directory to save results
#dir.create("./DailyAverageData/")
```


```{r dailyavg}
# calculates a dataframe of daily average values of sensor data, merges with metabolism dataframe, and returns merged dataframe
#
# metabolism_model  dataframe returned by metabolism modeling
# sensor_data       dataframe from StreamPULSE API
#

dailyavg <- function(sensor_data, metabolism_model){
  # if sensor data has a "bad data" flag, set value to NA
  sensor_data$value[sensor_data$flagtype %in% c("Bad Data")] <- NA
  
  # reshape sensor data from long format to wide format
  sensor_data <- tidyr::spread(sensor_data, key = variable, value = value)
  
  # sort data file and find daily averages
  sensor_data <- sensor_data %>%
    dplyr::group_by(date = lubridate::date(DateTime_UTC)) %>% 
    dplyr::summarise(Q_m3s.mean = mean(Discharge_m3s, na.rm = TRUE),
              DO_mgL.mean = mean(DO_mgL, na.rm = TRUE),
              DOsat_pct.mean = mean(DOsat_pct, na.rm = TRUE),
              Light_PAR.mean = mean(Light_PAR, na.rm = TRUE),
              WaterTemp_C.mean = mean(WaterTemp_C, na.rm = TRUE),
              Nitrate_mgL.mean = mean(Nitrate_mgL, na.rm = TRUE))
  
  # make sure metabolism model date column is correct class
  metabolism_model$date <- lubridate::date(metabolism_model$date)
  
  # combine with metabolism model predictions
  dailyavgs <- merge(sensor_data, metabolism_model, by = "date")
  return(dailyavgs)
}

eric.dailyavg <- dailyavg(eric_data, modelfit.eric)
steve.dailyavg <- dailyavg(steve_data, modelfit.steve)
desoto.dailyavg <- dailyavg(desoto_data, modelfit.desoto)
```

```{r correlations}
# Linear (pearson) correlation coefficient
# bounded from -1 to 1, near-zero values signify a weak correlation
# compute correlations for data that has a same-day complete pair
cormatrixr <- function(dailyavgs){
  cormatrix.site <- cor(dailyavgs[2:13], use = "pairwise.complete.obs")
  # set the diagonal (x to x pairs) of the correlation matrix to 0
  diag(cormatrix.site) <- NA
  cormatrix.site[lower.tri(cormatrix.site)] <- NA
  return(cormatrix.site)
}

cormatrix.eric <- cormatrixr(eric.dailyavg)
cormatrix.steve <- cormatrixr(steve.dailyavg)
cormatrix.desoto <- cormatrixr(desoto.dailyavg)

# should the data be described with a linear model?
# check out the residuals of the data
# if the dataset matches the regression model, the resisual plot
# should be a normally distributed cloud of points
# centered on 0

plot(resid(lm(GPP~Q_m3s.mean, data = eric.dailyavg)))
names(eric.dailyavg)

model <- 
lm(GPP ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)
model <- 
lm(GPP ~ Q_m3s.mean, data = eric.dailyavg)
plot(na.omit(eric.dailyavg$Q_m3s.mean), resid(model),
     ylab = "Residuals", xlab = "Q", main = "GPP, Eric")
abline(h=0)
xlabel

length(na.omit(eric.dailyavg$Q_m3s.mean))
length(resid(model))

model <- 
  lm(ER ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)

library(psych)
pairs.panels(eric.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(steve.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(desoto.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")
corPlot(desoto.dailyavg[c(2:8,11)])
```

```{r PCA}
# principal components analysis (PCA)
# first, standardize the data (because the variances are different)
# standardization scales the data, sets variance to 1 and mean to 0

# select variables we want in the PCA
PCAr <- function(dailyavgs){
  # remove date column, data code columns
  selects <- c("Q_m3s.mean", "DO_mgL.mean", "DOsat_pct.mean", 
               "Light_PAR.mean", "WaterTemp_C.mean", 
               "Nitrate_mgL.mean", "GPP", "ER")
  dailyavgs <- dailyavgs[names(dailyavgs) %in% selects]
  # scale data, sets mean to 0 and variance to 1
  data.scaled <- as.data.frame(scale(dailyavgs))
  # perform PCA on scaled data
  prcomp(na.omit(data.scaled))
}

eric.PCA <- PCAr(eric.dailyavg)
steve.PCA <- PCAr(steve.dailyavg)
desoto.PCA <- PCAr(desoto.dailyavg)

# kaiser's criterion
# only retain principal components for which the 
# variance is above 1 (if the data is standardized)
eric.PCA$sdev^2 # keep the first 3 principal components
steve.PCA$sdev^2 # keep the first 3 principal components
desoto.PCA$sdev^2 # keep the first 2 principal components

# check out the loadings of the principal components
eric.PCA$rotation[,1:2]
```

```{r plotting}
# axis labels -----------------------------------------------
# y axis label for GPP
ylabel_GPP <- textGrob(expression(paste("GPP (g ", ~O[2]~m^-2~d^-1, ")")),
                       rot = 90, gp = gpar(cex = 0.9))
# y axis label for ER
ylabel_ER <- textGrob(expression(paste("ER (g ", ~O[2]~m^-2~d^-1, ")")),
                      rot = 90, gp = gpar(cex = 0.9))
# x axis label for Q
xlabelQ <- textGrob(expression(paste("Q (", m^3, " ", s^-1, ")")), 
                    gp = gpar(cex = 0.9))
# DO mg/L
xlabelDO_mgL <- textGrob(expression(paste("DO (mg ", L^-1, ")")), 
                         gp = gpar(cex = 0.9))
# mean light
xlabelPAR <- textGrob(expression(paste("PAR")), 
                      gp = gpar(cex = 0.9))
# water temp
xlabelWaterTemp_C <- textGrob(expression(paste("T (", degree~C, ")")), 
                              gp = gpar(cex = 0.9))
# NO3
xlabelNO3_mgL <- textGrob(expression(paste("NO3 ( mg", L^-1, ")")), 
                          gp = gpar(cex = 0.9))

# Plotting -----------------------------------------------------------
# xvariable       character string, what you want to graph on the xaxis
# xlabel          textGrob for xaxis label

dailyavg_plots <- function(xvariable, xlabel){
  # lm fit
  fit <- summary(lm(eric.dailyavg[["GPP"]] ~ eric.dailyavg[[xvariable]]))
  # plot
  a <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "A") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["GPP"]] ~ steve.dailyavg[[xvariable]]))
  b <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "B") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["GPP"]] ~ desoto.dailyavg[[xvariable]]))
  c <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "C") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(eric.dailyavg[["ER"]] ~ eric.dailyavg[[xvariable]]))
  d <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) + 
    theme_classic() + labs(x = NULL, y = NULL, tag = "D") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["ER"]] ~ steve.dailyavg[[xvariable]]))
  e <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "E") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["ER"]] ~ desoto.dailyavg[[xvariable]]))
  f <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "F") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  gridExtra::grid.arrange(arrangeGrob(a, b, c, left = ylabel_GPP, ncol = 3, nrow = 1),
                          arrangeGrob(d, e, f, left = ylabel_ER, ncol = 3, nrow = 1),
                          bottom = xlabel)
}

# [A] [D] eric
# [B] [E] steve
# [C] [F] desoto

p1 <- dailyavg_plots(xvariable = "Q_m3s.mean", xlabel = xlabelQ)
p2 <- dailyavg_plots(xvariable = "DO_mgL.mean", xlabel = xlabelDO_mgL)
p3 <- dailyavg_plots(xvariable = "Light_PAR.mean", xlabel = xlabelPAR)
p4 <- dailyavg_plots(xvariable = "WaterTemp_C.mean", xlabel = xlabelWaterTemp_C)
p5 <- dailyavg_plots(xvariable = "Nitrate_mgL.mean", xlabel = xlabelNO3_mgL)

# save to file
ggsave(file = "./DailyAverageData/Q_GPPERplot.png", p1, width = 6, height = 4)
ggsave(file = "./DailyAverageData/DO_GPPERplot.png", p2, width = 6, height = 4)
ggsave(file = "./DailyAverageData/PAR_GPPERplot.png", p3, width = 6, height = 4)
ggsave(file = "./DailyAverageData/Temp_GPPERplot.png", p4, width = 6, height = 4)
ggsave(file = "./DailyAverageData/N_GPPERplot.png", p5, width = 6, height = 4)
```
