---
title: 'KAWN: Parameters vs Energetics'
author: "Michelle Catherine Kelly"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(lubridate)
library(tidyr)
library(grid)
library(gridExtra)
library(dplyr)
library(ggplot2)
library(ggpmisc)
library(imputeTS)
```


```{r dataload}
# pulling from the streamPULSE API will just pull in data that's useful for metabolism modeling, but we're interested in all data available. Therefore, download data from streamPULSE and load in these .csv files. 

# load sensor data from local files (same files as can be downloaded from streamPULSE)
eric_data <- read.csv("./Data/SensorData_StreamPULSE_Downloaded/KS_KANSASREASTLAWRENCE_sensorData.csv",
                      header = TRUE)
steve_data <- read.csv("./Data/SensorData_StreamPULSE_Downloaded/KS_KANSASRFALLLEAF_sensorData.csv", 
                      header = TRUE)
desoto_data <- read.csv("./Data/SensorData_StreamPULSE_Downloaded/KS_KANSASR_sensorData.csv", 
                        header = TRUE)

# make sure datetime is of correct class
eric_data$DateTime_UTC <- lubridate::mdy_hm(eric_data$DateTime_UTC)
steve_data$DateTime_UTC <- lubridate::mdy_hm(steve_data$DateTime_UTC)
desoto_data$DateTime_UTC <- lubridate::mdy_hm(desoto_data$DateTime_UTC)

# load in metabolism model results
modelfit.eric <- readRDS("./Outputs/MetabResults_Eric.RData")$predictions
modelfit.steve <- readRDS("./Outputs/MetabResults_Steve.RData")$predictions
modelfit.desoto <- readRDS("./Outputs/MetabResults_Desoto.RData")$predictions

```

```{r NO3Uptake.Desoto}
desoto_data$value[desoto_data$flagtype %in% c("Bad Data")] <- NA
desoto_data <- tidyr::spread(desoto_data, key = variable, value = value)

# hourly averages of NO3 concentration
desoto_uptake <- desoto_data %>%
  dplyr::group_by(DateTime_UTC = lubridate::round_date(DateTime_UTC, unit = "hour")) %>%
  dplyr::summarise(Q_m3s = mean(Discharge_m3s), 
                   Nitrate_mgL = mean(Nitrate_mgL))

# extrapolate gaps in data
desoto_uptake$Q_m3s <- imputeTS::na.interpolation(desoto_uptake$Q_m3s)
desoto_uptake$Nitrate_mgL<- imputeTS::na.interpolation(desoto_uptake$Nitrate_mgL)

# USGS field measurements
# 2018-03-01    Q = 1410 ft3/s      Channel area = 811 ft2
# 2018-04-24    Q = 2330 ft3/s      Channel area = 1400 ft2

# Append USGS field measurements and extrapolate in between
desoto_uptake$A_m2 <- NA
desoto_uptake$A_m2[desoto_uptake$DateTime_UTC >= ymd("2018-03-01") &
                     desoto_uptake$DateTime_UTC <= ymd("2018-03-02")] <- 75.3 #m2
desoto_uptake$A_m2[desoto_uptake$DateTime_UTC >= ymd("2018-04-24") &
                     desoto_uptake$DateTime_UTC <= ymd("2018-04-25")] <- 130.1 #m2
# extrapolate in between field measurements
desoto_uptake$A_m2 <- imputeTS::na.interpolation(desoto_uptake$A_m2)

# find maximum [NO3] in each day
desoto_NMax <- desoto_uptake %>% 
  dplyr::group_by(DateTime_UTC = lubridate::floor_date(DateTime_UTC, unit = "day")) %>%
  dplyr::summarise(Max.Nitrate_mgL = max(Nitrate_mgL))

# initialize uptake column
desoto_uptake$U_mgNm2day <- NA
i <- 1
# run loop to calculate uptake
for (i in 1:nrow(desoto_uptake)){
  # Q/A, [m3/s] / [m2] = [m/s]
  v <- desoto_uptake$Q_m3s[i] / desoto_uptake$A_m2[i]
  # time of day / 24 [unitless]
  hr <- hour(desoto_uptake$DateTime_UTC[i]) / 24
  date <- floor_date(desoto_uptake$DateTime_UTC[i], unit = "day")
  date.pre <- date - lubridate::days(1)
  
  # if theres a preceeding date,
  if (date.pre %in% desoto_NMax$DateTime_UTC){
    NMax.0 <- desoto_NMax$Max.Nitrate_mgL[desoto_NMax$DateTime_UTC == date.pre]
    NMax.24 <- desoto_NMax$Max.Nitrate_mgL[desoto_NMax$DateTime_UTC == date]
  
    desoto_uptake$U_mgNm2day[i] <- v * (NMax.0 * (1 - hr) + NMax.24 * hr -
                                          desoto_uptake$Nitrate_mgL[i])
    # unit conversions
    # currently: [m/s * mg/L], convert to [mg / s / m2]
    desoto_uptake$U_mgNm2day[i] <- desoto_uptake$U_mgNm2day[i] / 1000
    # convert from [mg/s/m2] to [mg m^-2 day^-1]
    desoto_uptake$U_mgNm2day[i] <- desoto_uptake$U_mgNm2day[i] * 1.15741e5
  } # exit loop for filling U
} # exit loop for calculating v, hr, date, date.pre

write.csv(desoto_uptake, file = "./Outputs/NitrateUptake_Desoto.csv", row.names = FALSE)
```

```{r uptakePlot}
# calculate daily average uptake rate
desoto_uptake.avg <- desoto_uptake %>%
  dplyr::group_by(date = lubridate::floor_date(DateTime_UTC, unit = "day")) %>%
  dplyr::summarise(U_mgNm2day = mean(U_mgNm2day))

# join uptake dataframe with GPP dataframe
desoto_uptake.avg$date <- as.Date(desoto_uptake.avg$date)
modelfit.desoto <- dplyr::full_join(desoto_uptake.avg, modelfit.desoto, by = "date")
modelfit.desoto <- modelfit.desoto[modelfit.desoto$date <= as.Date("2018-05-01"),]

# split by date
modelfit.desotoDuring <- modelfit.desoto[modelfit.desoto$date < as.Date("2018-04-01"),]
modelfit.desotoPost <- modelfit.desoto[modelfit.desoto$date >= as.Date("2018-04-01") &
                                         modelfit.desoto$date <= as.Date("2018-05-01"),]

# plot uptake through time during release
ggplot(modelfit.desoto, aes(x = date, y = U_mgNm2day)) +
  geom_line() +
  geom_point(shape = 21, size = 1.5, fill = "white") +
  theme_classic() + 
  labs(x = NULL, y = "Nitrate uptake, (mg-N m^-2 day^-1)") + 
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/DesotoUptake.png", height = 4, width = 5, units = "in")

ggplot(desoto_data, aes(x = DateTime_UTC, y = Nitrate_mgL)) +
  geom_point(shape = 21, size = 1, fill = "white") +
  theme_classic() + ylim(c(0, 1.5)) + 
  scale_x_datetime(limits = c(ymd_hms("2018-02-09 00:00:00"), ymd_hms("2018-02-20 00:00:00")), 
                   date_breaks = "2 days", date_labels = "%b %d") +
  labs(x = NULL, y = "Nitrate (mg-N L^-1)") +
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/DesotoDiel.png", height = 2.5, width = 3.5, units = "in")

summary(lm(U_mgNm2day~GPP, data = modelfit.desotoDuring))
summary(lm(U_mgNm2day~GPP, data = modelfit.desotoPost))
summary(lm(U_mgNm2day~ER, data = modelfit.desotoDuring))
summary(lm(U_mgNm2day~ER, data = modelfit.desotoPost))

ggplot(modelfit.desotoDuring, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm, se = TRUE, color = "red") +
  labs(x = "GPP", y = "Nitrate uptake, (mg-N m^-2 day^-1)") +
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/Desoto_UvsGPP_duringpump.png", height = 3.5, width = 3.5, units = "in")

ggplot(modelfit.desotoDuring, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desotoPost, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desotoPost, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)

summary(lm(U_mgNm2day~GPP, data = modelfit.desoto))
summary(lm(U_mgNm2day~ER, data = modelfit.desoto))

ggplot(modelfit.desoto, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desoto, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
```

```{r dailyavg}
# calculates a dataframe of daily average values of sensor data, merges with metabolism dataframe, and returns merged dataframe
#
# metabolism_model  dataframe returned by metabolism modeling
# sensor_data       dataframe from StreamPULSE API
#

dailyavg <- function(sensor_data, metabolism_model){
  # if sensor data has a "bad data" flag, set value to NA
  sensor_data$value[sensor_data$flagtype %in% c("Bad Data")] <- NA
  
  # reshape sensor data from long format to wide format
  sensor_data <- tidyr::spread(sensor_data, key = variable, value = value)
  
  # sort data file and find daily averages
  sensor_data <- sensor_data %>%
    dplyr::group_by(date = lubridate::date(DateTime_UTC)) %>% 
    dplyr::summarise(Q_m3s.mean = mean(Discharge_m3s, na.rm = TRUE),
              DO_mgL.mean = mean(DO_mgL, na.rm = TRUE),
              DOsat_pct.mean = mean(DOsat_pct, na.rm = TRUE),
              Light_PAR.mean = mean(Light_PAR, na.rm = TRUE),
              WaterTemp_C.mean = mean(WaterTemp_C, na.rm = TRUE),
              Nitrate_mgL.mean = mean(Nitrate_mgL, na.rm = TRUE))
  
  # make sure metabolism model date column is correct class
  metabolism_model$date <- lubridate::date(metabolism_model$date)
  
  # combine with metabolism model predictions
  dailyavgs <- merge(sensor_data, metabolism_model, by = "date")
  return(dailyavgs)
}

eric.dailyavg <- dailyavg(eric_data, modelfit.eric)
steve.dailyavg <- dailyavg(steve_data, modelfit.steve)
desoto.dailyavg <- dailyavg(desoto_data, modelfit.desoto)

#eric_data <- NULL
#modelfit.eric <- NULL
#steve_data <- NULL
#modelfit.steve <- NULL
#desoto_data <- NULL
#modelfit.desoto <- NULL
```

```{r correlations}
# Linear (pearson) correlation coefficient
# bounded from -1 to 1, near-zero values signify a weak correlation
# compute correlations for data that has a same-day complete pair
cormatrixr <- function(dailyavgs){
  cormatrix.site <- cor(dailyavgs[2:13], use = "pairwise.complete.obs")
  # set the diagonal (x to x pairs) of the correlation matrix to 0
  diag(cormatrix.site) <- NA
  cormatrix.site[lower.tri(cormatrix.site)] <- NA
  return(cormatrix.site)
}

cormatrix.eric <- cormatrixr(eric.dailyavg)
cormatrix.steve <- cormatrixr(steve.dailyavg)
cormatrix.desoto <- cormatrixr(desoto.dailyavg)

# should the data be described with a linear model?
# check out the residuals of the data
# if the dataset matches the regression model, the resisual plot
# should be a normally distributed cloud of points
# centered on 0

plot(resid(lm(GPP~Q_m3s.mean, data = eric.dailyavg)))
names(eric.dailyavg)

model <- 
lm(GPP ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)
model <- 
lm(GPP ~ Q_m3s.mean, data = eric.dailyavg)
plot(na.omit(eric.dailyavg$Q_m3s.mean), resid(model),
     ylab = "Residuals", xlab = "Q", main = "GPP, Eric")
abline(h=0)
xlabel

length(na.omit(eric.dailyavg$Q_m3s.mean))
length(resid(model))

model <- 
  lm(ER ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)

library(psych)
pairs.panels(eric.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(steve.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(desoto.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")
corPlot(desoto.dailyavg[c(2:8,11)])
```

```{r PCA}
# principal components analysis (PCA)
# first, standardize the data (because the variances are different)
# standardization scales the data, sets variance to 1 and mean to 0

# select variables we want in the PCA
PCAr <- function(dailyavgs){
  # remove date column, data code columns
  selects <- c("Q_m3s.mean", "DO_mgL.mean", "DOsat_pct.mean", 
               "Light_PAR.mean", "WaterTemp_C.mean", 
               "Nitrate_mgL.mean", "GPP", "ER")
  dailyavgs <- dailyavgs[names(dailyavgs) %in% selects]
  # scale data, sets mean to 0 and variance to 1
  data.scaled <- as.data.frame(scale(dailyavgs))
  # perform PCA on scaled data
  prcomp(na.omit(data.scaled))
}

eric.PCA <- PCAr(eric.dailyavg)
steve.PCA <- PCAr(steve.dailyavg)
desoto.PCA <- PCAr(desoto.dailyavg)

# kaiser's criterion
# only retain principal components for which the 
# variance is above 1 (if the data is standardized)
eric.PCA$sdev^2 # keep the first 3 principal components
steve.PCA$sdev^2 # keep the first 3 principal components
desoto.PCA$sdev^2 # keep the first 2 principal components

# check out the loadings of the principal components
eric.PCA$rotation[,1:2]
```

```{r plotting}
# axis labels -----------------------------------------------
# y axis label for GPP
ylabel_GPP <- textGrob(expression(paste("GPP (g ", ~O[2]~m^-2~d^-1, ")")),
                       rot = 90, gp = gpar(cex = 0.9))
# y axis label for ER
ylabel_ER <- textGrob(expression(paste("ER (g ", ~O[2]~m^-2~d^-1, ")")),
                      rot = 90, gp = gpar(cex = 0.9))
# x axis label for Q
xlabelQ <- textGrob(expression(paste("Q (", m^3, " ", s^-1, ")")), 
                    gp = gpar(cex = 0.9))
# DO mg/L
xlabelDO_mgL <- textGrob(expression(paste("DO (mg ", L^-1, ")")), 
                         gp = gpar(cex = 0.9))
# mean light
xlabelPAR <- textGrob(expression(paste("PAR")), 
                      gp = gpar(cex = 0.9))
# water temp
xlabelWaterTemp_C <- textGrob(expression(paste("T (", degree~C, ")")), 
                              gp = gpar(cex = 0.9))
# NO3
xlabelNO3_mgL <- textGrob(expression(paste("NO3 ( mg", L^-1, ")")), 
                          gp = gpar(cex = 0.9))

# Plotting -----------------------------------------------------------
# xvariable       character string, what you want to graph on the xaxis
# xlabel          textGrob for xaxis label

dailyavg_plots <- function(xvariable, xlabel){
  # lm fit
  fit <- summary(lm(eric.dailyavg[["GPP"]] ~ eric.dailyavg[[xvariable]]))
  # plot
  a <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "A") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["GPP"]] ~ steve.dailyavg[[xvariable]]))
  b <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "B") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["GPP"]] ~ desoto.dailyavg[[xvariable]]))
  c <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "C") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(eric.dailyavg[["ER"]] ~ eric.dailyavg[[xvariable]]))
  d <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) + 
    theme_classic() + labs(x = NULL, y = NULL, tag = "D") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["ER"]] ~ steve.dailyavg[[xvariable]]))
  e <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "E") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["ER"]] ~ desoto.dailyavg[[xvariable]]))
  f <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "F") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  gridExtra::grid.arrange(arrangeGrob(a, b, c, left = ylabel_GPP, ncol = 3, nrow = 1),
                          arrangeGrob(d, e, f, left = ylabel_ER, ncol = 3, nrow = 1),
                          bottom = xlabel)
}

# [A] [D] eric
# [B] [E] steve
# [C] [F] desoto

p1 <- dailyavg_plots(xvariable = "Q_m3s.mean", xlabel = xlabelQ)
p2 <- dailyavg_plots(xvariable = "DO_mgL.mean", xlabel = xlabelDO_mgL)
p3 <- dailyavg_plots(xvariable = "Light_PAR.mean", xlabel = xlabelPAR)
p4 <- dailyavg_plots(xvariable = "WaterTemp_C.mean", xlabel = xlabelWaterTemp_C)
p5 <- dailyavg_plots(xvariable = "Nitrate_mgL.mean", xlabel = xlabelNO3_mgL)

# save to file
ggsave(file = "./DailyAverageData/Q_GPPERplot.png", p1, width = 6, height = 4)
ggsave(file = "./DailyAverageData/DO_GPPERplot.png", p2, width = 6, height = 4)
ggsave(file = "./DailyAverageData/PAR_GPPERplot.png", p3, width = 6, height = 4)
ggsave(file = "./DailyAverageData/Temp_GPPERplot.png", p4, width = 6, height = 4)
ggsave(file = "./DailyAverageData/N_GPPERplot.png", p5, width = 6, height = 4)
```
