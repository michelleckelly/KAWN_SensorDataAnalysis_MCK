---
title: 'KAWN: Parameters vs Energetics'
author: "Michelle Catherine Kelly"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(lubridate)
library(tidyr)
library(grid)
library(gridExtra)
library(dplyr)
library(ggplot2)
library(ggpmisc)
library(imputeTS)
```

```{r dataload}
# Load in data that will be used for uptake calculations
# Note: we're not directly downloading this from the
# streamPULSE database because that will just return
# only the data that's useful for metabolism modeling.
# These CSV files are manually downloaded from the database

# Load in sensor data
eric_data <- 
  read.csv("./Data/StreamPULSE_DownloadedFrom/KS_KANSASREASTLAWRENCE_sensorData.csv",
           header = TRUE)
steve_data <- 
  read.csv("./Data/StreamPULSE_DownloadedFrom/KS_KANSASRFALLLEAF_sensorData.csv", 
           header = TRUE)
desoto_data <- 
  read.csv("./Data/StreamPULSE_DownloadedFrom/KS_KANSASR_sensorData.csv", 
           header = TRUE)

# Load in metabolism model results
modelfit.eric <- readRDS("./Outputs/MetabResults_Eric.RData")$predictions
modelfit.steve <- readRDS("./Outputs/MetabResults_Steve.RData")$predictions
modelfit.desoto <- readRDS("./Outputs/MetabResults_Desoto.RData")$predictions
```

```{r datasetup}
# Function to setup the data for uptake calculations
# Input: Sensor data frame
# Output: Sensor data frame with added columns for
#         local time, data flagged "Bad Data" removed

prepper <- function(sensor_data){
  # Format datetime column correctly
  sensor_data$DateTime_UTC <- 
    lubridate::ymd_hms(sensor_data$DateTime_UTC)
  # Add column for local time
  sensor_data$DateTime_CST <- 
    lubridate::with_tz(sensor_data$DateTime_UTC, 
                       tzone = "America/Chicago")
  #
  # Remove data that's been flagged as "Bad Data"
  sensor_data$value[sensor_data$flagtype %in% c("Bad Data")] <- NA
  # Remove flagtype and flagcomment columns
  sensor_data$flagtype <- NULL
  sensor_data$flagcomment <- NULL
  # Reshape dataframe from long to wide format
  sensor_data <- tidyr::spread(sensor_data, 
                               key = variable, value = value)
  # Create new dataframe with only data needed for uptake calculation
  sensor_uptake <- sensor_data[c("DateTime_UTC", "DateTime_CST",
                                 "Discharge_m3s", "Nitrate_mgL")]
  #
  # Extrapolate between missing values?
  #
  #
  # Return new dataframe
  return(sensor_uptake)
}

# Run function
eric_uptake <- prepper(eric_data)
steve_uptake <- prepper(steve_data)
desoto_uptake <- prepper(desoto_data)
```

```{r NO3Uptake.Equation1}
# Calculate NO3 uptake using the extrapolated diel method 
# (Heffernan and Cohen 2010, Eqn. 1)

# Input: the dataframe spit out by prepper()
# Output: Calculated NO3 Uptake

HC_Eqn1 <- function(prepped_df){
  # Add date index vector
  # (Based on CST local time)
  # Extract date into new column
  prepped_df$date <- 
    lubridate::date(prepped_df$DateTime_CST)
  # Count number of days since start
  for (i in 1:nrow(prepped_df)){
    prepped_df$day[i] <- 
      as.numeric(prepped_df$date[i] - prepped_df$date[1])
  }
  #
  # Find maximum nitrate concentration each 
  # (local time) day
  prepped_df <- prepped_df %>%
    dplyr::group_by(date) %>%
    dplyr::mutate(MaxNitrate = max(Nitrate_mgL, na.rm = TRUE))
  #
  # Use a static value for river bed area (m^2)
  # Average discharge at desoto = 61.3 m3/s
  # USGS field measuremnents
  # 2018-03-01    Q = 1410 ft3/s      Channel area = 811 ft2
  #                 = 39.93 m3/s                   = 75.34 m2
  # 2018-04-24    Q = 2330 ft3/s      Channel area = 1400 ft2
  #                 = 65.97 m3/s                   = 130.06 m2
  # Approximate river bed area as 130 m2 (for now)
  A_m2 <- 130
  #
  # Calculate water velocity [m/s]
  prepped_df$v_ms <- prepped_df$Discharge_m3s/A_m2
  # 
  # Calculate difference betweeen preceeding day's NitrateMax 
  # and Nitrate at time t
  prepped_df$DiffNitrate <- NA
  # Grab the row number of the start of day 1
  start <- which(prepped_df$day == 1)[1]
  # Loop from day 1 to end
  for(i in start:nrow(prepped_df)){
    # Get previous day: current day - 1
    prevday <- prepped_df$day[i] - 1
    # Get MaxNitrate during prevday
    MaxNitrate.prev <- unique(prepped_df$MaxNitrate[prepped_df$day == prevday])
    # Get current Nitrate
    Nitrate <- prepped_df$Nitrate_mgL[i]
    # Calculate difference
    prepped_df$DiffNitrate[i] <- MaxNitrate.prev - Nitrate
    # Iterate loop
    i <- i + 1
  }
  
  # Sum the differences from t = 0 to t = 24 for each day
  prepped_df <- prepped_df %>%
    group_by(day) %>%
    mutate(SumDiffNitrate = sum(DiffNitrate))
  # Multiply SumDiff and velocity, and correct for units
  # Q [m3/s] / A [m2] = v [m/s]
  # v [m/s] * [NO3] [mg-N/L] = U [m*mg-N / s*L]
  # U [m*mg-N / s*L] * [1000 L / 1 m3] = U [mg-N / m2*s]
  prepped_df$UaNO3_mgNm2s <- prepped_df$SumDiffNitrate * prepped_df$v_ms * 1000
  #
  # I don't know if this calculation is totally correct. The numbers seem
  # super high.
  #
  # Rename columns
  names(prepped_df)[names(prepped_df) == "MaxNitrate"] <- "Nitrate_DailyMax_mgNL"
  names(prepped_df)[names(prepped_df) == "v_ms"] <- "Velocity_ms"
  names(prepped_df)[names(prepped_df) == "DiffNitrate"] <- "DiffNitrate_mgNL"
  names(prepped_df)[names(prepped_df) == "SumDiffNitrate"] <- "SumDiffNitrate_mgNL"
  prepped_df$date <- NULL
  # Return dataframe
  return(prepped_df)
}

# Run function
eric_uptake_Eqn1 <- HC_Eqn1(eric_uptake)
steve_uptake_Eqn1 <- HC_Eqn1(steve_uptake)
desoto_uptake_Eqn1 <- HC_Eqn1(desoto_uptake)

# Save output as CSV
write.csv(desoto_uptake, file = "./Outputs/NitrateUptake_Desoto.csv", row.names = FALSE)

# Plot
ggplot(data = desoto_uptake_Eqn1, aes(DateTime_CST, UaNO3_mgNm2s)) +
  geom_line() +
  geom_point()
ggplot(data = modelfit.desoto$predictions, aes(date, GPP)) +
  geom_point()
```

```{r NO3Uptake.Eqn2}
# Calculate NO3 uptake using the integrated diel method 
# (Heffernan and Cohen 2010, Eqn. 2)

# Input: the dataframe spit out by prepper()
# Output: Calculated NO3 Uptake
HC_Eqn2 <- function(prepped_df){
  
}
```


```{r uptakePlot}
# calculate daily average uptake rate
desoto_uptake.avg <- desoto_uptake %>%
  dplyr::group_by(date = lubridate::floor_date(DateTime_UTC, unit = "day")) %>%
  dplyr::summarise(U_mgNm2day = mean(U_mgNm2day))

# join uptake dataframe with GPP dataframe
desoto_uptake.avg$date <- as.Date(desoto_uptake.avg$date)
modelfit.desoto <- dplyr::full_join(desoto_uptake.avg, modelfit.desoto, by = "date")
modelfit.desoto <- modelfit.desoto[modelfit.desoto$date <= as.Date("2018-05-01"),]

# split by date
modelfit.desotoDuring <- modelfit.desoto[modelfit.desoto$date < as.Date("2018-04-01"),]
modelfit.desotoPost <- modelfit.desoto[modelfit.desoto$date >= as.Date("2018-04-01") &
                                         modelfit.desoto$date <= as.Date("2018-05-01"),]

# plot uptake through time during release
ggplot(modelfit.desoto, aes(x = date, y = U_mgNm2day)) +
  geom_line() +
  geom_point(shape = 21, size = 1.5, fill = "white") +
  theme_classic() + 
  labs(x = NULL, y = "Nitrate uptake, (mg-N m^-2 day^-1)") + 
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/DesotoUptake.png", height = 4, width = 5, units = "in")

ggplot(desoto_data, aes(x = DateTime_UTC, y = Nitrate_mgL)) +
  geom_point(shape = 21, size = 1, fill = "white") +
  theme_classic() + ylim(c(0, 1.5)) + 
  scale_x_datetime(limits = c(ymd_hms("2018-02-09 00:00:00"), ymd_hms("2018-02-20 00:00:00")), 
                   date_breaks = "2 days", date_labels = "%b %d") +
  labs(x = NULL, y = "Nitrate (mg-N L^-1)") +
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/DesotoDiel.png", height = 2.5, width = 3.5, units = "in")

summary(lm(U_mgNm2day~GPP, data = modelfit.desotoDuring))
summary(lm(U_mgNm2day~GPP, data = modelfit.desotoPost))
summary(lm(U_mgNm2day~ER, data = modelfit.desotoDuring))
summary(lm(U_mgNm2day~ER, data = modelfit.desotoPost))

ggplot(modelfit.desotoDuring, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm, se = TRUE, color = "red") +
  labs(x = "GPP", y = "Nitrate uptake, (mg-N m^-2 day^-1)") +
  theme(panel.border = element_rect(color = "black", fill = NA))
ggsave(filename = "./Plots/Desoto_UvsGPP_duringpump.png", height = 3.5, width = 3.5, units = "in")

ggplot(modelfit.desotoDuring, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desotoPost, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desotoPost, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)

summary(lm(U_mgNm2day~GPP, data = modelfit.desoto))
summary(lm(U_mgNm2day~ER, data = modelfit.desoto))

ggplot(modelfit.desoto, aes(x = GPP, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
ggplot(modelfit.desoto, aes(x = ER, y = U_mgNm2day)) +
  geom_point(shape = 1) +
  geom_smooth(method = lm)
```

```{r dailyavg}
# calculates a dataframe of daily average values of sensor data, merges with metabolism dataframe, and returns merged dataframe
#
# metabolism_model  dataframe returned by metabolism modeling
# sensor_data       dataframe from StreamPULSE API
#

dailyavg <- function(sensor_data, metabolism_model){
  # if sensor data has a "bad data" flag, set value to NA
  sensor_data$value[sensor_data$flagtype %in% c("Bad Data")] <- NA
  
  # reshape sensor data from long format to wide format
  sensor_data <- tidyr::spread(sensor_data, key = variable, value = value)
  
  # sort data file and find daily averages
  sensor_data <- sensor_data %>%
    dplyr::group_by(date = lubridate::date(DateTime_UTC)) %>% 
    dplyr::summarise(Q_m3s.mean = mean(Discharge_m3s, na.rm = TRUE),
              DO_mgL.mean = mean(DO_mgL, na.rm = TRUE),
              DOsat_pct.mean = mean(DOsat_pct, na.rm = TRUE),
              Light_PAR.mean = mean(Light_PAR, na.rm = TRUE),
              WaterTemp_C.mean = mean(WaterTemp_C, na.rm = TRUE),
              Nitrate_mgL.mean = mean(Nitrate_mgL, na.rm = TRUE))
  
  # make sure metabolism model date column is correct class
  metabolism_model$date <- lubridate::date(metabolism_model$date)
  
  # combine with metabolism model predictions
  dailyavgs <- merge(sensor_data, metabolism_model, by = "date")
  return(dailyavgs)
}

eric.dailyavg <- dailyavg(eric_data, modelfit.eric)
steve.dailyavg <- dailyavg(steve_data, modelfit.steve)
desoto.dailyavg <- dailyavg(desoto_data, modelfit.desoto)

#eric_data <- NULL
#modelfit.eric <- NULL
#steve_data <- NULL
#modelfit.steve <- NULL
#desoto_data <- NULL
#modelfit.desoto <- NULL
```

```{r correlations}
# Linear (pearson) correlation coefficient
# bounded from -1 to 1, near-zero values signify a weak correlation
# compute correlations for data that has a same-day complete pair
cormatrixr <- function(dailyavgs){
  cormatrix.site <- cor(dailyavgs[2:13], use = "pairwise.complete.obs")
  # set the diagonal (x to x pairs) of the correlation matrix to 0
  diag(cormatrix.site) <- NA
  cormatrix.site[lower.tri(cormatrix.site)] <- NA
  return(cormatrix.site)
}

cormatrix.eric <- cormatrixr(eric.dailyavg)
cormatrix.steve <- cormatrixr(steve.dailyavg)
cormatrix.desoto <- cormatrixr(desoto.dailyavg)

# should the data be described with a linear model?
# check out the residuals of the data
# if the dataset matches the regression model, the resisual plot
# should be a normally distributed cloud of points
# centered on 0

plot(resid(lm(GPP~Q_m3s.mean, data = eric.dailyavg)))
names(eric.dailyavg)

model <- 
lm(GPP ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)
model <- 
lm(GPP ~ Q_m3s.mean, data = eric.dailyavg)
plot(na.omit(eric.dailyavg$Q_m3s.mean), resid(model),
     ylab = "Residuals", xlab = "Q", main = "GPP, Eric")
abline(h=0)
xlabel

length(na.omit(eric.dailyavg$Q_m3s.mean))
length(resid(model))

model <- 
  lm(ER ~ Q_m3s.mean + DO_mgL.mean + DOsat_pct.mean + Light_PAR.mean + 
     WaterTemp_C.mean + Nitrate_mgL.mean, data = eric.dailyavg)

library(psych)
pairs.panels(eric.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(steve.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")

pairs.panels(desoto.dailyavg[c(2:8,11)], method = "pearson", 
             cex = 3, ellipses = FALSE, rug = FALSE, hist.col = "white")
corPlot(desoto.dailyavg[c(2:8,11)])
```

```{r PCA}
# principal components analysis (PCA)
# first, standardize the data (because the variances are different)
# standardization scales the data, sets variance to 1 and mean to 0

# select variables we want in the PCA
PCAr <- function(dailyavgs){
  # remove date column, data code columns
  selects <- c("Q_m3s.mean", "DO_mgL.mean", "DOsat_pct.mean", 
               "Light_PAR.mean", "WaterTemp_C.mean", 
               "Nitrate_mgL.mean", "GPP", "ER")
  dailyavgs <- dailyavgs[names(dailyavgs) %in% selects]
  # scale data, sets mean to 0 and variance to 1
  data.scaled <- as.data.frame(scale(dailyavgs))
  # perform PCA on scaled data
  prcomp(na.omit(data.scaled))
}

eric.PCA <- PCAr(eric.dailyavg)
steve.PCA <- PCAr(steve.dailyavg)
desoto.PCA <- PCAr(desoto.dailyavg)

# kaiser's criterion
# only retain principal components for which the 
# variance is above 1 (if the data is standardized)
eric.PCA$sdev^2 # keep the first 3 principal components
steve.PCA$sdev^2 # keep the first 3 principal components
desoto.PCA$sdev^2 # keep the first 2 principal components

# check out the loadings of the principal components
eric.PCA$rotation[,1:2]
```

```{r plotting}
# axis labels -----------------------------------------------
# y axis label for GPP
ylabel_GPP <- textGrob(expression(paste("GPP (g ", ~O[2]~m^-2~d^-1, ")")),
                       rot = 90, gp = gpar(cex = 0.9))
# y axis label for ER
ylabel_ER <- textGrob(expression(paste("ER (g ", ~O[2]~m^-2~d^-1, ")")),
                      rot = 90, gp = gpar(cex = 0.9))
# x axis label for Q
xlabelQ <- textGrob(expression(paste("Q (", m^3, " ", s^-1, ")")), 
                    gp = gpar(cex = 0.9))
# DO mg/L
xlabelDO_mgL <- textGrob(expression(paste("DO (mg ", L^-1, ")")), 
                         gp = gpar(cex = 0.9))
# mean light
xlabelPAR <- textGrob(expression(paste("PAR")), 
                      gp = gpar(cex = 0.9))
# water temp
xlabelWaterTemp_C <- textGrob(expression(paste("T (", degree~C, ")")), 
                              gp = gpar(cex = 0.9))
# NO3
xlabelNO3_mgL <- textGrob(expression(paste("NO3 ( mg", L^-1, ")")), 
                          gp = gpar(cex = 0.9))

# Plotting -----------------------------------------------------------
# xvariable       character string, what you want to graph on the xaxis
# xlabel          textGrob for xaxis label

dailyavg_plots <- function(xvariable, xlabel){
  # lm fit
  fit <- summary(lm(eric.dailyavg[["GPP"]] ~ eric.dailyavg[[xvariable]]))
  # plot
  a <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "A") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["GPP"]] ~ steve.dailyavg[[xvariable]]))
  b <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "B") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["GPP"]] ~ desoto.dailyavg[[xvariable]]))
  c <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "GPP")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "C") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$GPP)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(eric.dailyavg[["ER"]] ~ eric.dailyavg[[xvariable]]))
  d <- ggplot(data = eric.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) + 
    theme_classic() + labs(x = NULL, y = NULL, tag = "D") +
    annotate("text", vjust = 1, x = 0.5*(max(eric.dailyavg[[xvariable]], na.rm=T) +
                                           min(eric.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(eric.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(steve.dailyavg[["ER"]] ~ steve.dailyavg[[xvariable]]))
  e <- ggplot(data = steve.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "E") +
    annotate("text", vjust = 1, x = 0.5*(max(steve.dailyavg[[xvariable]], na.rm=T) +
                                           min(steve.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(steve.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  fit <- summary(lm(desoto.dailyavg[["ER"]] ~ desoto.dailyavg[[xvariable]]))
  f <- ggplot(data = desoto.dailyavg, aes_string(x = xvariable, y = "ER")) +
    geom_point(shape = 1) +
    theme_classic() + labs(x = NULL, y = NULL, tag = "F") +
    annotate("text", vjust = 1, x = 0.5*(max(desoto.dailyavg[[xvariable]], na.rm=T) +
                                           min(desoto.dailyavg[[xvariable]], na.rm=T)), 
             y = max(na.omit(desoto.dailyavg$ER)),
             label = paste0("p = ", signif(fit$coefficients[2,4], 2)))
  
  gridExtra::grid.arrange(arrangeGrob(a, b, c, left = ylabel_GPP, ncol = 3, nrow = 1),
                          arrangeGrob(d, e, f, left = ylabel_ER, ncol = 3, nrow = 1),
                          bottom = xlabel)
}

# [A] [D] eric
# [B] [E] steve
# [C] [F] desoto

p1 <- dailyavg_plots(xvariable = "Q_m3s.mean", xlabel = xlabelQ)
p2 <- dailyavg_plots(xvariable = "DO_mgL.mean", xlabel = xlabelDO_mgL)
p3 <- dailyavg_plots(xvariable = "Light_PAR.mean", xlabel = xlabelPAR)
p4 <- dailyavg_plots(xvariable = "WaterTemp_C.mean", xlabel = xlabelWaterTemp_C)
p5 <- dailyavg_plots(xvariable = "Nitrate_mgL.mean", xlabel = xlabelNO3_mgL)

# save to file
ggsave(file = "./DailyAverageData/Q_GPPERplot.png", p1, width = 6, height = 4)
ggsave(file = "./DailyAverageData/DO_GPPERplot.png", p2, width = 6, height = 4)
ggsave(file = "./DailyAverageData/PAR_GPPERplot.png", p3, width = 6, height = 4)
ggsave(file = "./DailyAverageData/Temp_GPPERplot.png", p4, width = 6, height = 4)
ggsave(file = "./DailyAverageData/N_GPPERplot.png", p5, width = 6, height = 4)
```
